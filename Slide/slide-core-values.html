<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Slide — Giá trị cốt lõi (Questions & Methods)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Playfair+Display:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{ --title-font: 'Playfair Display', serif; --body-font: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Arial; --bg-1:#fdfbfb; --bg-2:#f8f9fa; --brand:#E07A5F; --muted:#667085; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;padding:0;background:linear-gradient(170deg,var(--bg-1),var(--bg-2));font-family:var(--body-font);color:#071422}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:clamp(18px,3vw,48px);}
  .stage{width:100%;max-width:980px;position:relative;z-index:2}
  .card{background:#fff;border-radius:12px;padding:28px;box-shadow:0 12px 36px rgba(9,30,66,0.06);overflow:hidden;position:relative}

  /* decorative overlay (unique) */
  .decorative-overlay{position:absolute;inset:0;z-index:0;pointer-events:none;overflow:visible}
  .decorative-overlay svg{display:block;pointer-events:none}
  .sparkle{position:absolute;right:-40px;top:-40px;width:420px;opacity:0.92;mix-blend-mode:soft-light;filter:blur(6px)}
  .wave{position:absolute;left:-50px;bottom:-30px;width:460px;opacity:0.7;mix-blend-mode:multiply;filter:blur(0.8px)}

  .content{position:relative;z-index:2}
  .title{font-family:var(--title-font);font-size:clamp(22px,4vw,32px);margin:0 0 6px;font-weight:800}
  .subtitle{color:var(--muted);margin:0 0 18px}

  .view{min-height:200px;border-radius:10px;padding:18px;position:relative}
  .view-inner{padding:12px;border-radius:8px}
  .questions ol{margin:0;padding-left:1.05rem;color:#08202b;line-height:1.6;font-size:1.06rem}
  .questions li{margin:0.8rem 0}
  .explain p,.explain ul{margin:0 0 .8rem 0;color:var(--muted)}
  .explain ul{padding-left:1.05rem}

  /* animation helpers */
  .anim-enter{opacity:0;transform:translateY(12px)}
  .anim-visible{opacity:1;transform:none;transition:transform 420ms cubic-bezier(.2,.95,.2,1),opacity 420ms ease}

  @media (max-width:720px){ .sparkle,.wave{display:none} .card{padding:18px} }
  @media (prefers-reduced-motion: reduce){ .anim-visible,.view-inner{transition:none!important;animation:none!important} }

  .sr-only{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}
</style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div class="card" role="main" aria-label="Slide Giá trị cốt lõi">

        <div class="decorative-overlay" aria-hidden="true">
          <!-- decorative 1: soft sparkle blob (inline SVG) -->
          <svg class="sparkle" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg" focusable="false" aria-hidden="true">
            <defs>
              <linearGradient id="g1" x1="0" x2="1"><stop offset="0" stop-color="#FFF7F2"/><stop offset="1" stop-color="#FFF1EB"/></linearGradient>
              <filter id="f1" x="-40%" y="-40%" width="180%" height="180%"><feGaussianBlur stdDeviation="14"/></filter>
            </defs>
            <g filter="url(#f1)" opacity="0.95"><path d="M120 220c40-110 220-150 360-120 80 18 150 60 170 100 18 36-8 72-40 106-70 78-190 136-310 118C140 412 86 332 120 220z" fill="url(#g1)"/></g>
          </svg>

          <!-- decorative 2: subtle diagonal pattern -->
          <svg class="wave" viewBox="0 0 500 360" xmlns="http://www.w3.org/2000/svg" focusable="false" aria-hidden="true">
            <defs>
              <pattern id="dots" x="0" y="0" width="14" height="14" patternUnits="userSpaceOnUse"><circle cx="2" cy="2" r="1.1" fill="#E07A5F" fill-opacity="0.05"/></pattern>
            </defs>
            <g transform="rotate(14 250 180)" opacity="0.08"><rect x="-50" y="-30" width="600" height="28" fill="#fff"/></g>
            <rect width="100%" height="100%" fill="url(#dots)"/>
          </svg>
        </div>

        <div class="content">
          <h2 class="title">Xác định giá trị cốt lõi</h2>
          <p class="subtitle">Các câu hỏi hướng dẫn và phương pháp để làm rõ giá trị cốt lõi của doanh nghiệp.</p>

          <div id="views" aria-live="polite">
            <section id="view-0" class="view" data-step="0" aria-hidden="false">
              <div class="view-inner questions">
                <ol>
                  <li class="q-item"><strong>Chúng ta đại diện cho điều gì?</strong> (Điều gì làm nên con người/doanh nghiệp này?)</li>
                  <li class="q-item"><strong>Những hành vi nào đã giúp chúng ta thành công trong quá khứ?</strong> (Những nguyên tắc nào chúng ta luôn áp dụng?)</li>
                  <li class="q-item"><strong>Điều gì là quan trọng nhất đối với chúng ta, ngay cả khi gặp khó khăn?</strong> (Thứ mà ta sẽ không bao giờ thỏa hiệp).</li>
                  <li class="q-item"><strong>Chúng ta muốn nhân viên/đồng nghiệp/khách hàng nói gì về chúng ta?</strong></li>
                </ol>
              </div>
            </section>

            <section id="view-1" class="view" data-step="1" aria-hidden="true" style="display:none;">
              <div class="view-inner explain">
                <p><strong>Xác định giá trị cốt lõi của Doanh Nghiệp có thể được tiến hành theo 2 phương pháp chủ yếu:</strong></p>
                <ul>
                  <li><strong>Phương pháp chuyên gia:</strong> sử dụng ý kiến của các chuyên gia có kinh nghiệm trong xây dựng văn hóa doanh nghiệp để lựa chọn các giá trị cốt lõi. Các chuyên gia thường dùng phương pháp brainstorming để đưa ra các giá trị, sau đó trao đổi thảo luận để thống nhất.</li>
                  <li><strong>Phương pháp điều tra xã hội học:</strong> (thường sử dụng bảng hỏi và phỏng vấn) Doanh nghiệp tiến hành điều tra xã hội học các đối tượng có liên quan bên trong và bên ngoài doanh nghiệp để làm rõ những giá trị văn hóa cốt lõi của doanh nghiệp.</li>
                </ul>
              </div>
            </section>
          </div>

          <p id="notes" class="sr-only">Ghi chú: Slide mô tả câu hỏi hướng dẫn và hai phương pháp xác định giá trị cốt lõi (chuyên gia & điều tra xã hội học).</p>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  // internal state
  let step = 0; // 0 = questions, 1 = explanation
  let running = [];
  let timeouts = [];

  const view0 = document.getElementById('view-0');
  const view1 = document.getElementById('view-1');

  function clearTimeouts(){ timeouts.forEach(t=>clearTimeout(t)); timeouts = []; }

  function setInitial(viewEl){
    if(!viewEl) return;
    const items = viewEl.querySelectorAll('h1,h2,h3,p,ol,li,ul');
    items.forEach(n=>{
      try { n.style.opacity = '0'; n.style.transform = 'translateY(12px)'; } catch(e){}
      n.classList.add('anim-enter');
      n.classList.remove('anim-visible');
    });
  }

  function animateView(viewEl, opts={}){
    if(!viewEl) return [];
    const nodes = Array.from(viewEl.querySelectorAll('h1,h2,h3,p,ol,li,ul'));
    const anims = [];
    const baseDelay = opts.baseDelay || 30;
    const per = opts.per || 100;
    const duration = opts.duration || 520;
    nodes.forEach((n,i)=>{
      // clear inline styles
      n.style.opacity = '';
      n.style.transform = '';
      try {
        const a = n.animate([
          { opacity: 0, transform: 'translateY(12px)' },
          { opacity: 1, transform: 'translateY(0)' }
        ], { duration, delay: baseDelay + i*per, easing: 'cubic-bezier(.2,.95,.2,1)', fill: 'forwards' });
        anims.push(a);
      } catch(e){
        // fallback
        n.classList.remove('anim-enter'); n.classList.add('anim-visible');
      }
    });
    return anims;
  }

  function resetAnimationsOn(viewEl){
    // cancel running WAAPI animations belonging to viewEl
    running = running.filter(anim => {
      try {
        const target = anim.effect && anim.effect.target;
        if (target && viewEl.contains(target)) { anim.cancel(); return false; }
      } catch(e){}
      return true;
    });
    // clear timeouts
    clearTimeouts();
    // restore initial classes/styles
    const items = viewEl.querySelectorAll('h1,h2,h3,p,ol,li,ul');
    items.forEach(n=>{
      n.classList.add('anim-enter'); n.classList.remove('anim-visible');
      try { n.style.opacity = '0'; n.style.transform = 'translateY(12px)'; } catch(e){}
    });
  }

  function showStep(n, doAnimate=true){
    n = (n === 1) ? 1 : 0;
    // reset current view animations
    if (step === 0) resetAnimationsOn(view0); else resetAnimationsOn(view1);

    // hide/show
    view0.style.display = (n === 0) ? 'block' : 'none';
    view1.style.display = (n === 1) ? 'block' : 'none';
    view0.setAttribute('aria-hidden', n === 0 ? 'false' : 'true');
    view1.setAttribute('aria-hidden', n === 1 ? 'false' : 'true');

    // set initial
    setInitial(n === 0 ? view0 : view1);

    if (doAnimate) {
      const t = setTimeout(()=>{
        const anims = animateView(n === 0 ? view0 : view1, { baseDelay: 30, per: 110, duration: 520 });
        running = running.concat(anims);
      }, 30);
      timeouts.push(t);
    }
    step = n;
  }

  // message handling from parent
  window.addEventListener('message', (ev)=>{
    const msg = ev.data || {};
    if (!msg || typeof msg.type !== 'string') return;
    switch(msg.type){
      case 'reset':
        // stop animations and go to step 0 (questions), but don't auto-animate
        resetAnimationsOn(view0); resetAnimationsOn(view1);
        view0.style.display = 'block'; view1.style.display = 'none';
        view0.setAttribute('aria-hidden','false'); view1.setAttribute('aria-hidden','true');
        setInitial(view0); setInitial(view1);
        step = 0;
        break;

      case 'animate-slide':
        // animate current view; accept options
        const opts = msg.options || {};
        resetAnimationsOn(step===0?view0:view1);
        const anims = animateView(step===0?view0:view1, { baseDelay: opts.baseDelay||30, per: opts.per||110, duration: opts.duration||520 });
        running = running.concat(anims);
        break;

      case 'setStep':
        // switch to requested internal step
        const s = (typeof msg.step === 'number') ? (msg.step ? 1 : 0) : 0;
        const animate = (msg.animate === undefined) ? true : !!msg.animate;
        showStep(s, animate);
        break;

      case 'getNotes':
        try { ev.source.postMessage({ type: 'notes', notes: document.getElementById('notes')?.textContent || '' }, '*'); } catch(e){}
        break;

      default:
        break;
    }
  }, false);

  // parse ?step=1 initial param
  function parseInitialStep(){ try { const qp = new URLSearchParams(window.location.search); return qp.get('step')==='1' ? 1 : 0; } catch(e){ return 0; } }

  window.addEventListener('load', ()=>{
    const initial = parseInitialStep();
    // set initial view but do not animate until parent asks
    view0.style.display = (initial===0)?'block':'none';
    view1.style.display = (initial===1)?'block':'none';
    view0.setAttribute('aria-hidden', initial===0 ? 'false' : 'true');
    view1.setAttribute('aria-hidden', initial===1 ? 'false' : 'true');
    setInitial(view0); setInitial(view1);
    step = initial;
    // Note: parent is expected to postMessage('animate-slide') when iframe becomes visible.
  }, {once:true});

  // expose API for debugging inside iframe devtools
  window._slideCoreValues = { showStep, resetAnimationsOn, animateView };
})();
</script>
</body>
</html>
