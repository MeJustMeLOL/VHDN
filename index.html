<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slides — Cached Iframe Pool (with Fullscreen)</title>
  <style>
    /* (giữ nguyên toàn bộ CSS như file gốc) */
    :root{
      --bg:#071018; --card:#0f1724; --accent:#58a6ff; --muted:#9fb8e6; --fg:#e6eef6;
      --sidebar-w:280px; --collapsed-w:56px; --info-h:72px;
      --fade-dur:320ms;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Arial}
    .shell{display:flex;gap:12px;max-width:1200px;margin:18px auto;padding:12px;box-sizing:border-box;align-items:flex-start;transition:padding .18s}
    .left{width:var(--collapsed-w);min-width:var(--collapsed-w);background:#071425;border-radius:8px;padding:8px;color:var(--muted);box-sizing:border-box;display:flex;flex-direction:column;gap:8px;transition:width .28s cubic-bezier(.2,.9,.2,1), box-shadow .2s, transform .28s;overflow:visible; position:relative;}
    .left:hover, .left.expanded { width:var(--sidebar-w); box-shadow:0 6px 24px rgba(0,0,0,0.45); }
    .left h4{margin:0 0 6px 0;color:var(--accent); font-size:13px; opacity:0; transform:translateX(-6px); transition:opacity .18s ease, transform .18s ease}
    .left:hover h4, .left.expanded h4 { opacity:1; transform:none; }
    .left:not(.expanded) .brand > div { display:none; }
    .tree-list{display:flex;flex-direction:column;gap:6px;overflow:auto;max-height:70vh;padding-right:6px;opacity:0; transform:translateX(-8px); transition:opacity .22s ease, transform .22s ease;pointer-events:none;}
    .left:hover .tree-list, .left.expanded .tree-list{ opacity:1; transform:none; pointer-events:auto; }
    .tree-item{background:transparent;color:var(--muted);border:0;padding:8px 10px;border-radius:6px;text-align:left;cursor:pointer;outline:none;white-space:nowrap; overflow:hidden; text-overflow:ellipsis;transition:background .12s, color .12s, transform .12s;}
    .tree-item:hover{background:rgba(88,166,255,0.06);color:#cfe8ff; transform:translateX(2px)}
    .tree-item.active{background:var(--accent);color:#042038;font-weight:600}
    .left .mini-toggle{display:flex;align-items:center;justify-content:center;height:40px;border-radius:6px;border:0;background:transparent;color:var(--muted);cursor:pointer}
    .left .mini-toggle:focus{outline:2px solid rgba(88,166,255,0.14)}
    .left .brand{display:flex;align-items:center;gap:8px;padding:6px 4px}
    .left .brand .logo{width:36px;height:36px;border-radius:6px;background:linear-gradient(90deg,#0b2233,#062232);display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:700}
    .main{flex:1;display:flex;flex-direction:column;gap:8px;position:relative}
    .controls{display:flex;gap:8px;align-items:center;background:transparent;padding:6px 8px;border-radius:10px;transition:opacity .22s ease, transform .22s ease;opacity:0; transform:translateY(-6px); pointer-events:none;position:relative; z-index:30;}
    .frame-wrap-hover .controls,.controls:focus-within,.controls:hover,#frame-wrap:focus-within .controls { opacity:1; transform:none; pointer-events:auto; }
    button.control{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:600;transition:background .16s ease, color .16s ease, transform .12s ease, box-shadow .12s;box-shadow: 0 2px 6px rgba(3,8,15,0.12);backdrop-filter: blur(6px);}
    button.control:hover{ background:rgba(88,166,255,0.08); color:var(--accent); transform:translateY(-2px); }
    .status{ margin-left:auto;color:rgba(159,184,230,0.6); font-size:13px }
    #frame-wrap{position:relative;width:100%;height:72vh;min-height:440px;background:var(--card);border-radius:8px;overflow:hidden;outline:none;z-index:10}
    #iframePoolAnchor{position:relative;width:100%;height:100%}
    iframe{position:absolute;inset:0;border:0;width:100%;height:100%;transition:opacity var(--fade-dur) cubic-bezier(.2,.9,.2,1), transform var(--fade-dur) cubic-bezier(.2,.9,.2,1);opacity:0; transform:translateY(6px); will-change:opacity, transform;backface-visibility:hidden; -webkit-backface-visibility:hidden; transform-style:preserve-3d;transform: translateZ(0) translateY(6px); contain:content; background:transparent;}
    iframe.top{z-index:2;opacity:1;transform:translateZ(0) translateY(0)}
    iframe.bottom{z-index:1}
    iframe[aria-hidden="true"]{pointer-events:none}
    body.immersive {overflow: hidden;}
    body.immersive .shell {max-width: 100%;margin:0;padding:0;}
    body.immersive .left {transform: translateX(-140%);opacity:0;pointer-events:none;}
    body.immersive .controls,body.immersive .info-bar,body.immersive .tree-list,body.immersive .status {opacity:0 !important;pointer-events:none !important;}
    body.immersive .main { padding:0; }
    body.immersive #frame-wrap{position:fixed;left:0; right:0; top:0; bottom:0;width:100%; height:100%;border-radius:0;z-index:99999;background:#000;}
    .full-toggle {position:absolute; right:12px; top:12px; z-index:10005;background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.04);color:var(--fg); padding:8px 10px; border-radius:8px; cursor:button;backdrop-filter: blur(6px); display:flex; gap:8px; align-items:center;transition:transform .12s ease, opacity .12s;}
    .full-toggle:hover{ transform:translateY(-3px); }
    body.immersive .full-toggle { display:flex; left:12px; right:auto; top:12px; }
    .info-bar{position:absolute;left:12px;right:12px;bottom:12px;height:var(--info-h);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;display:flex;align-items:center;gap:12px;padding:12px;box-sizing:border-box;opacity:0;transform:translateY(10px);transition:opacity .22s ease, transform .22s ease;pointer-events:none;color:var(--muted)}
    .info-bar.visible{opacity:1;transform:none;pointer-events:auto}
    .info-title{font-weight:700;color:var(--fg);font-size:15px}
    .info-notes{font-size:13px;color:#cfe8ff;opacity:0.95;max-height:44px;overflow:hidden}
    .info-controls{margin-left:auto;display:flex;gap:8px}
    .small{font-size:13px;padding:6px 8px;border-radius:6px;cursor:pointer;border:0;background:rgba(255,255,255,0.03);color:var(--muted)}
    .left::after{content:"";position:absolute;left:8px; top:50%; transform:translateY(-50%);width:3px; height:40px; border-radius:3px;background: linear-gradient(180deg, rgba(88,166,255,0.16), rgba(88,166,255,0.06)); opacity:0.7;}
    @media (max-width:900px){.shell{flex-direction:column}.left{width:auto;min-width:unset;display:flex;flex-direction:row;overflow:auto;gap:8px;padding:8px}.tree-list{flex-direction:row}}
    .fullscreen-active .left,.fullscreen-active .controls,.fullscreen-active .status,.fullscreen-active .info-bar,.fullscreen-active .notes { display: none !important;}
    .fullscreen-active #frame-wrap { width:100% !important; height:100% !important; position:fixed !important; inset:0 !important; z-index:9999 !important; background:#000; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="left" id="leftPanel" aria-hidden="false">
      <div class="brand">
        <div class="logo">P</div>
        <div style="display:flex;flex-direction:column">
          <div style="font-size:13px;color:var(--fg);opacity:0.95">Project</div>
          <div style="font-size:11px;color:var(--muted)">Slides</div>
        </div>
      </div>

      <button class="mini-toggle" id="navToggle" title="Mở/đóng điều hướng" aria-pressed="false">☰</button>
      <div id="treeList" class="tree-list" role="navigation" aria-label="Danh sách slide"></div>
    </div>

    <div class="main">
      <div class="controls" id="controlsRow" aria-hidden="false">
        <button id="prevBtn" class="control">◀ Prev</button>
        <button id="nextBtn" class="control">Next ▶</button>
        <button id="autoplayBtn" class="control">Autoplay ▶</button>
        <button id="fullBtn" class="control" title="Toàn màn hình">⤢ Full</button>
        <div class="status" id="status">Slide 1 / ?</div>
      </div>

      <div id="frame-wrap" tabindex="0" aria-label="Slide frame">
        <div id="iframePoolAnchor"></div>
        <button class="full-toggle" id="fullToggleMini" title="Toàn màn hình">⤢ Full</button>
        <div id="infoBar" class="info-bar" aria-hidden="true">
          <div style="display:flex;flex-direction:column">
            <div id="infoTitle" class="info-title">Slide title</div>
            <div id="infoNotes" class="info-notes">(chưa có notes)</div>
          </div>
          <div class="info-controls">
            <button id="infoPrev" class="small">◀</button>
            <button id="infoNext" class="small">▶</button>
            <button id="infoOpen" class="small">Open</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Fullscreen + nav tweaks (giữ nguyên) */
(function(){
  const bodyEl = document.body;
  const fullBtn = document.getElementById('fullBtn');
  const fullToggleMini = document.getElementById('fullToggleMini');
  const leftPanel = document.getElementById('leftPanel');
  const frameWrap = document.getElementById('frame-wrap');
  const shell = document.querySelector('.shell');

  function enterImmersive(){
    if (bodyEl.classList.contains('immersive')) return;
    bodyEl.classList.add('immersive');
    shell.classList.remove('frame-wrap-hover');
    if (frameWrap.requestFullscreen) {
      frameWrap.requestFullscreen();
    } else if (frameWrap.webkitRequestFullscreen) {
      frameWrap.webkitRequestFullscreen();
    } else if (frameWrap.msRequestFullscreen) {
      frameWrap.msRequestFullscreen();
    }
    try {
      const topIframe = document.querySelector('#iframePoolAnchor iframe.top');
      if (topIframe && topIframe.contentWindow) {
        topIframe.contentWindow.postMessage({ type: 'fullscreen', active: true }, '*');
      }
    } catch (err) { /* ignore */ }
    setTimeout(()=> frameWrap.focus(), 100);
  }

  function exitImmersive(){
    if (!bodyEl.classList.contains('immersive')) return;
    bodyEl.classList.remove('immersive');
    if (document.fullscreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    setTimeout(()=> frameWrap.focus(), 100);
  }
  function toggleImmersive(){ bodyEl.classList.contains('immersive') ? exitImmersive() : enterImmersive(); }
  fullBtn.addEventListener('click', (e)=> { e.stopPropagation(); toggleImmersive(); });
  fullToggleMini.addEventListener('click', (e)=> { e.stopPropagation(); toggleImmersive(); });
  frameWrap.addEventListener('dblclick', (e)=> { e.stopPropagation(); toggleImmersive(); });
  document.addEventListener('fullscreenchange', ()=>{ if (!document.fullscreenElement){ bodyEl.classList.remove('immersive'); } });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && bodyEl.classList.contains('immersive')) { exitImmersive(); }
  });
  frameWrap.addEventListener('mouseenter', ()=> { shell.classList.add('frame-wrap-hover'); });
  frameWrap.addEventListener('mouseleave', ()=> { shell.classList.remove('frame-wrap-hover'); });

  const navToggle = document.getElementById('navToggle');
  navToggle.addEventListener('click', (e)=> {
    leftPanel.classList.toggle('expanded');
    if (bodyEl.classList.contains('immersive') && leftPanel.classList.contains('expanded')) {
      bodyEl.classList.add('immersive-show-nav');
      const observer = new MutationObserver(()=> {
        if (!leftPanel.classList.contains('expanded')) {
          bodyEl.classList.remove('immersive-show-nav');
          observer.disconnect();
        }
      });
      observer.observe(leftPanel, { attributes: true, attributeFilter: ['class'] });
    }
  });
  window._immersiveAPI = { enterImmersive, exitImmersive, toggleImmersive };
})();
</script>

<!-- Slide-pool controller (đã chỉnh để gửi 'reset' khi preload xong và chỉ animate khi hiển thị) -->
<script>
(function(){
  const slideMap = [
    { key:'slide-1', url:'slide-1.html', title:'1 — Giới thiệu', notes:'Ghi chú: giới thiệu' },
    { key:'slide-2', url:'slide-2.html', title:'2 — Nội dung', notes:'Ghi chú: nội dung' },
    { key:'slide-3', url:'slide-3.html', title:'3 — Thêm ví dụ', notes:'Ghi chú: ví dụ' },
    { key:'slide-3-1', url:'slide-3-1.html', title:'3-1 — Kết luận'},
    { key:'slide-3-2', url:'slide-3-2.html', title:'3-2 — Kết luận'},
    { key:'slide-3-3', url:'slide-3-3.html', title:'3-3 — Kết luận'},
    { key:'slide-3-4', url:'slide-3-4.html', title:'3-4 — Kết luận'},
    { key:'slide-4', url:'slide-4.html', title:'4 — Kết luận', notes:'slide 4' },
    { key:'slide-4-1', url:'slide-4-1.html', title:'4-1 — Kết luận',stepCount: 2},
    { key:'slide-4-2', url:'slide-4-2.html', title:'4-2 — Kết luận', notes:'Ghi chú: kết luận' },
    { key:'slide-5', url:'slide-5.html', title:'5 — Kết luận', notes:'slide 5' },
    { key:'slide-5-1', url:'slide-5-1.html', title:'5 — Kết luận', notes:'slide 5' },
    { key:'slide-5-2', url:'slide-5-2.html', title:'5 — Kết luận', notes:'slide 5' },
    { key:'slide-5-3', url:'slide-5-3.html', title:'5 — Kết luận', notes:'slide 5' },
    { key:'slide-5-4', url:'slide-5-4.html', title:'5 — Kết luận', notes:'slide 5' },
    { key:'slide-5-5', url:'slide-5-5.html', title:'5 — Kết luận', notes:'slide 5' },
    { key:'slide-6', url:'slide-6.html', title:'6 — Kết luận', notes:'slide 5' },
    { key:'slide-6', url:'slide-6-1.html', title:'6 — Kết luận', notes:'slide 5' },
    { key:'slide-6', url:'slide-6-2.html', title:'6 — Kết luận', notes:'slide 5' },
    { key:'slide-6', url:'slide-6-3.html', title:'6 — Kết luận', notes:'slide 5' },
    { key:'slide-6', url:'slide-6-4.html', title:'6 — Kết luận', notes:'slide 5' },
    { key:'slide-7', url:'slide-7.html', title:'7 — Kết luận'},
    { key:'slide-8', url:'slide-8.html', title:'8 — Kết luận'},
    { key:'slide-9', url:'slide-9.html', title:'8 — Kết luận'},
    { key:'slide-10', url:'slide-10.html', title:'8 — Kết luận'},
    { key:'slide-11', url:'slide-11.html', title:'8 — Kết luận'},
    { key:'slide-12', url:'slide-12.html', title:'8 — Kết luận'},
    { key:'slide-13', url:'slide-13.html', title:'8 — Kết luận'},
    { key:'slide-14', url:'slide-14.html', title:'8 — Kết luận'},

    { key:'slide-20', url:'slide-20.html', title:'8 — Kết luận'},
    { key:'slide-21', url:'slide-21.html', title:'8 — Kết luận'},
    { key:'slide-22', url:'slide-22.html', title:'8 — Kết luận'},
    { key:'slide-23', url:'slide-23.html', title:'8 — Kết luận'},
    { key:'slide-24', url:'slide-24.html', title:'8 — Kết luận' }
  ];

  // DOM
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const autoplayBtn = document.getElementById('autoplayBtn');
  const statusEl = document.getElementById('status');
  const treeList = document.getElementById('treeList');
  const infoBar = document.getElementById('infoBar');
  const infoTitle = document.getElementById('infoTitle');
  const infoNotes = document.getElementById('infoNotes');
  const infoPrev = document.getElementById('infoPrev');
  const infoNext = document.getElementById('infoNext');
  const infoOpen = document.getElementById('infoOpen');
  const poolAnchor = document.getElementById('iframePoolAnchor');

  // state
  let currentIndex = 0;
  let autoplay = false;
  let autoplayTimer = null;
  let isTransitioning = false;
  let lastClickedIndex = null;
  let currentIframe = null;
  let slideSteps = {}; // stores internal step per slide index
  const iframePool = new Map();

  function updateStatus(){ statusEl.textContent = `Slide ${currentIndex+1} / ${slideMap.length}`; }

  function buildTree(){
    treeList.innerHTML = '';
    slideMap.forEach((s, idx) => {
      const b = document.createElement('button');
      b.className = 'tree-item';
      b.textContent = s.title || s.key;
      b.dataset.index = idx;
      b.addEventListener('click', () => {
        lastClickedIndex = idx;
        highlightTree(idx);
        showIndex(idx);
        document.getElementById('frame-wrap').focus();
      });
      treeList.appendChild(b);
    });
    highlightTree(currentIndex);
  }
  function highlightTree(idx){
    const items = treeList.querySelectorAll('.tree-item');
    items.forEach((it,i) => it.classList.toggle('active', i === idx));
  }

  // info bar show/hide
  let hoverTimer = null;
  function scheduleInfoShow(){ clearTimeout(hoverTimer); hoverTimer = setTimeout(()=> { infoBar.classList.add('visible'); infoBar.setAttribute('aria-hidden','false'); }, 600); }
  function cancelInfoShow(){ clearTimeout(hoverTimer); }
  function hideInfo(){ cancelInfoShow(); infoBar.classList.remove('visible'); infoBar.setAttribute('aria-hidden','true'); }
  const frameWrapEl = document.getElementById('frame-wrap');
  frameWrapEl.addEventListener('mouseenter', scheduleInfoShow);
  frameWrapEl.addEventListener('mouseleave', hideInfo);

  function updateInfoContent(){
    const s = slideMap[currentIndex];
    infoTitle.textContent = s.title || s.key;
    infoNotes.textContent = s.notes || '(chưa có notes)';
  }
  infoPrev.addEventListener('click', ()=> { lastClickedIndex = null; showPrev(); frameWrapEl.focus(); });
  infoNext.addEventListener('click', ()=> { lastClickedIndex = null; showNext(); frameWrapEl.focus(); });
  infoOpen.addEventListener('click', ()=> { window.open(slideMap[currentIndex].url, '_blank'); });

  // create iframe for index (lazy: will set src immediately here; we ensure parent sends 'reset' on load)
  function makeIframeFor(index, url){
    if (iframePool.has(index)) return iframePool.get(index);
    const iframe = document.createElement('iframe');
    iframe.setAttribute('data-index', index);
    iframe.dataset.index = index;
    iframe.src = url; // keep preload behavior; we will ensure reset on load
    iframe.style.position = 'absolute';
    iframe.style.inset = '0';
    iframe.style.border = '0';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.className = 'bottom';
    iframe.setAttribute('aria-hidden','true');
    iframe.setAttribute('allow','autoplay');
    iframe.title = `slide-${index+1}`;

    let resolveLoad;
    const loadingPromise = new Promise((res) => { resolveLoad = res; });

    iframe.addEventListener('load', () => {
      iframe.__loaded = true;
      try {
        // IMPORTANT CHANGE: ngay khi iframe preload xong, gửi 1 lệnh 'reset' để chắc chắn
        // trạng thái animation ở trong iframe được reset (không tự chạy animation khi preload).
        iframe.contentWindow.postMessage({ type: 'reset' }, '*');
      } catch (e) { /* ignore */ }
      try { resolveLoad(); } catch(e){}
      // ensure internal step is reset in parent tracking
      slideSteps[index] = 0;
    });

    poolAnchor.appendChild(iframe);
    const entry = { el: iframe, loadingPromise, resolveLoad };
    iframePool.set(index, entry);
    return entry;
  }

  async function ensureIframeLoaded(index){
    if (index < 0 || index >= slideMap.length) throw new Error('index out of range');
    const s = slideMap[index];
    const existing = iframePool.get(index);
    if (existing) {
      if (existing.el.__loaded) return existing.el;
      await existing.loadingPromise;
      return existing.el;
    } else {
      const entry = makeIframeFor(index, s.url);
      await entry.loadingPromise;
      return entry.el;
    }
  }

  function computeBase(){ return (lastClickedIndex !== null) ? lastClickedIndex : currentIndex; }

  // ----------------- START: Internal-step aware navigation -----------------
  /*
    Behavior:
    - When an iframe is shown, parent posts {type:'setStep', step: <n>, animate: false}
      to let iframe set its internal view without animating immediately.
    - Then parent posts {type:'animate-slide'} to trigger animation on visible iframe.
    - If slideMap[index].stepCount > 1, parent will toggle internal step on Next/Prev
      (instead of changing iframe) until steps exhausted.
  */

  async function showIndexCached(index){
    if (index < 0 || index >= slideMap.length) return;
    // initialize stored step if needed
    slideSteps[index] = slideSteps[index] || 0;

    if (index === currentIndex) {
      // already visible — ensure it's in sync (send setStep & animate)
      try {
        const desired = slideSteps[index] || 0;
        if (currentIframe && currentIframe.contentWindow) {
          currentIframe.contentWindow.postMessage({ type: 'setStep', step: desired, animate: false }, '*');
          setTimeout(()=> {
            try { currentIframe.contentWindow.postMessage({ type: 'animate-slide', options: { baseDelay:30, per:110, duration:520 } }, '*'); } catch(e){}
          }, 40);
        }
      } catch(e){}
      return;
    }

    while (isTransitioning) await new Promise(r => setTimeout(r, 30));
    isTransitioning = true;
    try {
      const targetEl = await ensureIframeLoaded(index);

      // if have current iframe, reset it and hide
      if (currentIframe && currentIframe !== targetEl){
        try { currentIframe.contentWindow.postMessage({ type: 'reset' }, '*'); } catch(e){}
        currentIframe.classList.remove('top');
        currentIframe.classList.add('bottom');
        currentIframe.setAttribute('aria-hidden','true');
      }

      // bring target up
      targetEl.classList.add('top');
      targetEl.classList.remove('bottom');
      targetEl.setAttribute('aria-hidden','false');

      // allow frame paint
      await new Promise(r => requestAnimationFrame(r));

      // wait transition end (or timeout)
      await new Promise(resolve => {
        let done = false;
        function onEnd(e){
          if (e.target !== targetEl || e.propertyName !== 'opacity') return;
          if (done) return; done = true;
          targetEl.removeEventListener('transitionend', onEnd);
          resolve();
        }
        targetEl.addEventListener('transitionend', onEnd);
        setTimeout(()=> { if (!done) { done=true; targetEl.removeEventListener('transitionend', onEnd); resolve(); } }, 900);
      });

      // update state
      currentIframe = targetEl;
      currentIndex = index;
      lastClickedIndex = null;
      highlightTree(index);
      updateStatus();
      updateInfoContent();

      // Determine desired internal step for this slide
      const entry = slideMap[index] || {};
      const desiredStep = (typeof entry.initialStep === 'number') ? entry.initialStep : (slideSteps[index] || 0);

      // send setStep (do not animate yet), then animate-slide
      try {
        currentIframe.contentWindow.postMessage({ type: 'setStep', step: desiredStep, animate: false }, '*');
      } catch(e){ /* ignore */ }

      // small tick then trigger animation on visible iframe
      setTimeout(()=> {
        try {
          currentIframe.contentWindow.postMessage({ type: 'animate-slide', options: { baseDelay: 30, per: 110, duration: 520 } }, '*');
        } catch(e){}
      }, 40);

      // ask for notes if supported
      try { currentIframe.contentWindow.postMessage({type:'getNotes'}, '*'); } catch(e){}
    } finally {
      isTransitioning = false;
    }
  }

  // wrapper (keeps API)
  async function showIndex(index){ return showIndexCached(index); }

  // Next/Prev: if current slide has internal steps (stepCount > 1) then
  // toggle internal step inside the same iframe; otherwise move to next/prev iframe.
  function showNext(){
    const s = slideMap[currentIndex] || {};
    const stepCount = (typeof s.stepCount === 'number') ? s.stepCount : 1;
    // if slide supports internal steps and not on last step, increment internal step
    if (stepCount > 1) {
      slideSteps[currentIndex] = slideSteps[currentIndex] || 0;
      if (slideSteps[currentIndex] < stepCount - 1) {
        slideSteps[currentIndex] += 1;
        // instruct iframe to change step and animate
        try {
          currentIframe.contentWindow.postMessage({ type: 'setStep', step: slideSteps[currentIndex], animate: false }, '*');
          setTimeout(()=> {
            try { currentIframe.contentWindow.postMessage({ type: 'animate-slide', options: { baseDelay: 30, per:110, duration:520 } }, '*'); } catch(e){}
          }, 40);
        } catch(e){}
        return;
      }
    }
    // otherwise go to next iframe entry
    const base = computeBase();
    const next = Math.min(slideMap.length-1, base+1);
    lastClickedIndex = null;
    showIndex(next);
  }

  function showPrev(){
    const s = slideMap[currentIndex] || {};
    const stepCount = (typeof s.stepCount === 'number') ? s.stepCount : 1;
    // if slide supports internal steps and not on first step, decrement internal step
    if (stepCount > 1) {
      slideSteps[currentIndex] = slideSteps[currentIndex] || 0;
      if (slideSteps[currentIndex] > 0) {
        slideSteps[currentIndex] -= 1;
        try {
          currentIframe.contentWindow.postMessage({ type: 'setStep', step: slideSteps[currentIndex], animate: false }, '*');
          setTimeout(()=> {
            try { currentIframe.contentWindow.postMessage({ type: 'animate-slide', options: { baseDelay: 30, per:110, duration:520 } }, '*'); } catch(e){}
          }, 40);
        } catch(e){}
        return;
      }
    }
    // otherwise navigate to previous iframe
    const base = computeBase();
    const prev = Math.max(0, base-1);
    lastClickedIndex = null;
    showIndex(prev);
  }
  // ----------------- END: Internal-step aware navigation -----------------

  prevBtn.addEventListener('click', ()=> { lastClickedIndex = null; showPrev(); frameWrapEl.focus(); });
  nextBtn.addEventListener('click', ()=> { lastClickedIndex = null; showNext(); frameWrapEl.focus(); });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { e.preventDefault(); lastClickedIndex = null; showNext(); }
    if (e.key === 'ArrowLeft' || e.key === 'PageUp') { e.preventDefault(); lastClickedIndex = null; showPrev(); }
    if (e.key === ' '){ e.preventDefault(); toggleAutoplay(); }
    if (e.key.toLowerCase() === 'n') {
      const left = document.getElementById('leftPanel');
      left.classList.toggle('expanded');
    }
  });

  function startAutoplay(){
    stopAutoplay();
    autoplay = true; autoplayBtn.textContent = 'Autoplay ◼';
    autoplayTimer = setInterval(()=> {
      if (currentIndex < slideMap.length - 1) showNext();
      else { stopAutoplay(); }
    }, 4200);
  }
  function stopAutoplay(){ autoplay = false; autoplayBtn.textContent = 'Autoplay ▶'; if (autoplayTimer){ clearInterval(autoplayTimer); autoplayTimer = null; } }
  function toggleAutoplay(){ if (autoplay) stopAutoplay(); else startAutoplay(); }
  autoplayBtn.addEventListener('click', toggleAutoplay);

  // build and initial show
  function initialSetup(){
    buildTree();
    updateStatus();
    updateInfoContent();

    // create only iframe 0 immediately (vẫn preload các iframe khác nếu bạn muốn,
    // nhưng chúng ta đã đảm bảo gửi 'reset' khi preload xong).
    const e0 = makeIframeFor(0, slideMap[0].url);
    e0.loadingPromise.then(() => {
      currentIframe = e0.el;
      e0.el.classList.add('top');
      e0.el.classList.remove('bottom');
      e0.el.setAttribute('aria-hidden','false');

      // GỌI: khi slide 0 hiển thị lần đầu, gửi animate-slide thay vì 'show'
      try { e0.el.contentWindow.postMessage({type:'animate-slide', options:{selector:'.animate-item', stagger:120}}, '*'); } catch(e){}
      try { e0.el.contentWindow.postMessage({type:'getNotes'}, '*'); } catch(e){}
    });

    // preload next to reduce latency (optional)
    if (slideMap.length > 1) makeIframeFor(1, slideMap[1].url);
  }

  window._iframePoolAPI = { makeIframeFor, ensureIframeLoaded, showIndex, showNext, showPrev, iframePool, slideMap };

  initialSetup();

  window.addEventListener('beforeunload', ()=> {
    try { if (currentIframe) currentIframe.contentWindow.postMessage({type:'hide'}, '*'); } catch(e){}
  });

})();
</script>
</body>
</html>
