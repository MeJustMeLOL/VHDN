<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slides — Cached Iframe Pool (with Fullscreen)</title>
  <style>
    /* (giữ nguyên toàn bộ CSS như file gốc) */
    :root{
      --bg:#071018; --card:#0f1724; --accent:#58a6ff; --muted:#9fb8e6; --fg:#e6eef6;
      --sidebar-w:280px; --collapsed-w:56px; --info-h:72px;
      --fade-dur:320ms;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Arial}
    .shell{display:flex;gap:12px;max-width:1200px;margin:18px auto;padding:12px;box-sizing:border-box;align-items:flex-start;transition:padding .18s}
    .left{width:var(--collapsed-w);min-width:var(--collapsed-w);background:#071425;border-radius:8px;padding:8px;color:var(--muted);box-sizing:border-box;display:flex;flex-direction:column;gap:8px;transition:width .28s cubic-bezier(.2,.9,.2,1), box-shadow .2s, transform .28s;overflow:visible; position:relative;}
    .left:hover, .left.expanded { width:var(--sidebar-w); box-shadow:0 6px 24px rgba(0,0,0,0.45); }
    .left h4{margin:0 0 6px 0;color:var(--accent); font-size:13px; opacity:0; transform:translateX(-6px); transition:opacity .18s ease, transform .18s ease}
    .left:hover h4, .left.expanded h4 { opacity:1; transform:none; }
    .left:not(.expanded) .brand > div { display:none; }
    .tree-list{display:flex;flex-direction:column;gap:6px;overflow:auto;max-height:70vh;padding-right:6px;opacity:0; transform:translateX(-8px); transition:opacity .22s ease, transform .22s ease;pointer-events:none;}
    .left:hover .tree-list, .left.expanded .tree-list{ opacity:1; transform:none; pointer-events:auto; }
    .tree-item{background:transparent;color:var(--muted);border:0;padding:8px 10px;border-radius:6px;text-align:left;cursor:pointer;outline:none;white-space:nowrap; overflow:hidden; text-overflow:ellipsis;transition:background .12s, color .12s, transform .12s;}
    .tree-item:hover{background:rgba(88,166,255,0.06);color:#cfe8ff; transform:translateX(2px)}
    .tree-item.active{background:var(--accent);color:#042038;font-weight:600}
    .left .mini-toggle{display:flex;align-items:center;justify-content:center;height:40px;border-radius:6px;border:0;background:transparent;color:var(--muted);cursor:pointer}
    .left .mini-toggle:focus{outline:2px solid rgba(88,166,255,0.14)}
    .left .brand{display:flex;align-items:center;gap:8px;padding:6px 4px}
    .left .brand .logo{width:36px;height:36px;border-radius:6px;background:linear-gradient(90deg,#0b2233,#062232);display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:700}
    .main{flex:1;display:flex;flex-direction:column;gap:8px;position:relative}
    .controls{display:flex;gap:8px;align-items:center;background:transparent;padding:6px 8px;border-radius:10px;transition:opacity .22s ease, transform .22s ease;opacity:0; transform:translateY(-6px); pointer-events:none;position:relative; z-index:30;}
    .frame-wrap-hover .controls,.controls:focus-within,.controls:hover,#frame-wrap:focus-within .controls { opacity:1; transform:none; pointer-events:auto; }
    button.control{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:600;transition:background .16s ease, color .16s ease, transform .12s ease, box-shadow .12s;box-shadow: 0 2px 6px rgba(3,8,15,0.12);backdrop-filter: blur(6px);}
    button.control:hover{ background:rgba(88,166,255,0.08); color:var(--accent); transform:translateY(-2px); }
    .status{ margin-left:auto;color:rgba(159,184,230,0.6); font-size:13px }
    #frame-wrap{position:relative;width:100%;height:72vh;min-height:440px;background:var(--card);border-radius:8px;overflow:hidden;outline:none;z-index:10}
    #iframePoolAnchor{position:relative;width:100%;height:100%}
    iframe{position:absolute;inset:0;border:0;width:100%;height:100%;transition:opacity var(--fade-dur) cubic-bezier(.2,.9,.2,1), transform var(--fade-dur) cubic-bezier(.2,.9,.2,1);opacity:0; transform:translateY(6px); will-change:opacity, transform;backface-visibility:hidden; -webkit-backface-visibility:hidden; transform-style:preserve-3d;transform: translateZ(0) translateY(6px); contain:content; background:transparent;}
    iframe.top{z-index:2;opacity:1;transform:translateZ(0) translateY(0)}
    iframe.bottom{z-index:1}
    iframe[aria-hidden="true"]{pointer-events:none}
    body.immersive {overflow: hidden;}
    body.immersive .shell {max-width: 100%;margin:0;padding:0;}
    body.immersive .left {transform: translateX(-140%);opacity:0;pointer-events:none;}
    body.immersive .controls,body.immersive .info-bar,body.immersive .tree-list,body.immersive .status {opacity:0 !important;pointer-events:none !important;}
    body.immersive .main { padding:0; }
    body.immersive #frame-wrap{position:fixed;left:0; right:0; top:0; bottom:0;width:100%; height:100%;border-radius:0;z-index:99999;background:#000;}
    .full-toggle {position:absolute; right:12px; top:12px; z-index:10005;background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.04);color:var(--fg); padding:8px 10px; border-radius:8px; cursor:button;backdrop-filter: blur(6px); display:flex; gap:8px; align-items:center;transition:transform .12s ease, opacity .12s;}
    .full-toggle:hover{ transform:translateY(-3px); }
    body.immersive .full-toggle { display:flex; left:12px; right:auto; top:12px; }
    .info-bar{position:absolute;left:12px;right:12px;bottom:12px;height:var(--info-h);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;display:flex;align-items:center;gap:12px;padding:12px;box-sizing:border-box;opacity:0;transform:translateY(10px);transition:opacity .22s ease, transform .22s ease;pointer-events:none;color:var(--muted)}
    .info-bar.visible{opacity:1;transform:none;pointer-events:auto}
    .info-title{font-weight:700;color:var(--fg);font-size:15px}
    .info-notes{font-size:13px;color:#cfe8ff;opacity:0.95;max-height:44px;overflow:hidden}
    .info-controls{margin-left:auto;display:flex;gap:8px}
    .small{font-size:13px;padding:6px 8px;border-radius:6px;cursor:pointer;border:0;background:rgba(255,255,255,0.03);color:var(--muted)}
    .left::after{content:"";position:absolute;left:8px; top:50%; transform:translateY(-50%);width:3px; height:40px; border-radius:3px;background: linear-gradient(180deg, rgba(88,166,255,0.16), rgba(88,166,255,0.06)); opacity:0.7;}
    @media (max-width:900px){.shell{flex-direction:column}.left{width:auto;min-width:unset;display:flex;flex-direction:row;overflow:auto;gap:8px;padding:8px}.tree-list{flex-direction:row}}
    .fullscreen-active .left,.fullscreen-active .controls,.fullscreen-active .status,.fullscreen-active .info-bar,.fullscreen-active .notes { display: none !important;}
    .fullscreen-active #frame-wrap { width:100% !important; height:100% !important; position:fixed !important; inset:0 !important; z-index:9999 !important; background:#000; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="left" id="leftPanel" aria-hidden="false">
      <div class="brand">
        <div class="logo">P</div>
        <div style="display:flex;flex-direction:column">
          <div style="font-size:13px;color:var(--fg);opacity:0.95">Project</div>
          <div style="font-size:11px;color:var(--muted)">Slides</div>
        </div>
      </div>

      <button class="mini-toggle" id="navToggle" title="Mở/đóng điều hướng" aria-pressed="false">☰</button>
      <div id="treeList" class="tree-list" role="navigation" aria-label="Danh sách slide"></div>
    </div>

    <div class="main">
      <div class="controls" id="controlsRow" aria-hidden="false">
        <button id="prevBtn" class="control">◀ Prev</button>
        <button id="nextBtn" class="control">Next ▶</button>
        <button id="autoplayBtn" class="control">Autoplay ▶</button>
        <button id="fullBtn" class="control" title="Toàn màn hình">⤢ Full</button>
        <div class="status" id="status">Slide 1 / ?</div>
      </div>

      <div id="frame-wrap" tabindex="0" aria-label="Slide frame">
        <div id="iframePoolAnchor"></div>
        <button class="full-toggle" id="fullToggleMini" title="Toàn màn hình">⤢ Full</button>
        <div id="infoBar" class="info-bar" aria-hidden="true">
          <div style="display:flex;flex-direction:column">
            <div id="infoTitle" class="info-title">Slide title</div>
            <div id="infoNotes" class="info-notes">(chưa có notes)</div>
          </div>
          <div class="info-controls">
            <button id="infoPrev" class="small">◀</button>
            <button id="infoNext" class="small">▶</button>
            <button id="infoOpen" class="small">Open</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Fullscreen + nav tweaks (giữ nguyên) */
(function(){
  const bodyEl = document.body;
  const fullBtn = document.getElementById('fullBtn');
  const fullToggleMini = document.getElementById('fullToggleMini');
  const leftPanel = document.getElementById('leftPanel');
  const frameWrap = document.getElementById('frame-wrap');
  const shell = document.querySelector('.shell');

  function enterImmersive(){
    if (bodyEl.classList.contains('immersive')) return;
    bodyEl.classList.add('immersive');
    shell.classList.remove('frame-wrap-hover');
    if (frameWrap.requestFullscreen) {
      frameWrap.requestFullscreen();
    } else if (frameWrap.webkitRequestFullscreen) {
      frameWrap.webkitRequestFullscreen();
    } else if (frameWrap.msRequestFullscreen) {
      frameWrap.msRequestFullscreen();
    }
    try {
      const topIframe = document.querySelector('#iframePoolAnchor iframe.top');
      if (topIframe && topIframe.contentWindow) {
        topIframe.contentWindow.postMessage({ type: 'fullscreen', active: true }, '*');
      }
    } catch (err) { console.debug('enterImmersive postMessage error', err); }
    setTimeout(()=> frameWrap.focus(), 100);
  }

  function exitImmersive(){
    if (!bodyEl.classList.contains('immersive')) return;
    bodyEl.classList.remove('immersive');
    if (document.fullscreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    setTimeout(()=> frameWrap.focus(), 100);
  }
  function toggleImmersive(){ bodyEl.classList.contains('immersive') ? exitImmersive() : enterImmersive(); }
  fullBtn.addEventListener('click', (e)=> { e.stopPropagation(); toggleImmersive(); });
  fullToggleMini.addEventListener('click', (e)=> { e.stopPropagation(); toggleImmersive(); });
  frameWrap.addEventListener('dblclick', (e)=> { e.stopPropagation(); toggleImmersive(); });
  document.addEventListener('fullscreenchange', ()=>{ if (!document.fullscreenElement){ bodyEl.classList.remove('immersive'); } });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && bodyEl.classList.contains('immersive')) { exitImmersive(); }
  });
  frameWrap.addEventListener('mouseenter', ()=> { shell.classList.add('frame-wrap-hover'); });
  frameWrap.addEventListener('mouseleave', ()=> { shell.classList.remove('frame-wrap-hover'); });

  const navToggle = document.getElementById('navToggle');
  navToggle.addEventListener('click', (e)=> {
    leftPanel.classList.toggle('expanded');
    if (bodyEl.classList.contains('immersive') && leftPanel.classList.contains('expanded')) {
      bodyEl.classList.add('immersive-show-nav');
      const observer = new MutationObserver(()=> {
        if (!leftPanel.classList.contains('expanded')) {
          bodyEl.classList.remove('immersive-show-nav');
          observer.disconnect();
        }
      });
      observer.observe(leftPanel, { attributes: true, attributeFilter: ['class'] });
    }
  });
  window._immersiveAPI = { enterImmersive, exitImmersive, toggleImmersive };
})();
</script>

<!-- Slide-pool controller (đã chỉnh để preload 4 frames, giảm delay, add debug + retry) -->
<script>
(function(){
  const slideMap = [
    { key:'slide-1', url:'aviation-slide-01.html', title:'01: Báo Cáo Sự Cố Hàng Không', notes: 'Trang tiêu đề của bài trình bày Báo cáo các sự cố hàng không liên quan đến thời tiết cực đoan.' },
    { key:'slide-2', url:'aviation-slide-02.html', title:'02: Giới Thiệu', notes: 'Thời tiết cực đoan thường là nguyên nhân hoặc nhân tố nguy hiểm trong nhiều sự cố hàng không. Báo cáo này tập hợp và phân tích các sự cố chính thức đã được điều tra, chỉ rõ nguyên nhân, hậu quả, và bài học rút ra.' },
    { key:'slide-3', url:'aviation-slide-03.html', title:'03: Các Hiện Tượng Chính', notes: 'Bốn hiện tượng thời tiết chính ảnh hưởng đến hàng không: Bão dông và Mưa đá, Gió cắt (Microburst), Sương mù dày, và Tuyết & Băng giá.' },
    { key:'slide-4', url:'aviation-slide-04.html', title:'04: Case Study: Mưa Dông', notes: 'Case Study 1: Mưa Dông & Mưa Đá - Chuyến bay Southern Airways 242 và bài học về việc bay xuyên qua tâm bão.' },
    { key:'slide-5', url:'aviation-slide-05.html', title:'05: Diễn Biến (Mưa Dông)', notes: 'Timeline 3 giai đoạn của sự cố Southern Airways 242: Bay vào vùng bão, mất cả hai động cơ do mưa đá, và buộc phải hạ cánh khẩn cấp xuống xa lộ.' },
    { key:'slide-6', url:'aviation-slide-06.html', title:'06: Nguyên Nhân (Mưa Dông)', notes: 'Phân tích nguyên nhân: Sự phụ thuộc quá mức vào radar thời tiết trên máy bay và những hạn chế của nó (nhiễu xạ), cùng với việc thiếu thông tin cảnh báo kịp thời.' },
    { key:'slide-7', url:'aviation-slide-07.html', title:'07: Giải Pháp (Mưa Dông)', notes: 'Các giải pháp được đưa ra: Cải tiến quy định cung cấp thông tin thời tiết, nâng cao huấn luyện về hạn chế của radar và quy trình cấm bay vào tâm bão.', stepCount: 2 },
    { key:'slide-8', url:'aviation-slide-08.html', title:'08: Case Study: Gió Cắt', notes: 'Case Study 2: Gió Cắt (Wind Shear) - Phân tích các thảm kịch Delta 191 và Pan Am 759.' },
    { key:'slide-9', url:'aviation-slide-09.html', title:'09: Cơ Chế Của Gió Cắt', notes: 'Giải thích cơ chế 3 bước của gió cắt: Tăng lực nâng đột ngột (headwind), mất độ cao nhanh chóng (downdraft), và mất tốc độ/lực nâng (tailwind).', stepCount: 4 },
    { key:'slide-10', url:'aviation-slide-10.html', title:'10: Diễn Biến (Gió Cắt)', notes: 'Timeline 3 giai đoạn của sự cố Delta 191: Tiếp cận sân bay DFW trong cơn dông, gặp microburst cực mạnh, và mất kiểm soát, rơi cách đường băng không xa.' },
    { key:'slide-11', url:'aviation-slide-11.html', title:'11: Giải Pháp (Gió Cắt)', notes: 'Các giải pháp công nghệ và huấn luyện: Hệ thống cảnh báo tại sân bay (LLWAS, TDWR), cảnh báo trên máy bay (EGPWS), và các bài huấn luyện trong buồng lái mô phỏng.' },
    { key:'slide-12', url:'aviation-slide-12.html', title:'12: Case Study: Sương Mù', notes: 'Case Study 3: Sương Mù - Thảm họa Tenerife, tai nạn thảm khốc nhất lịch sử hàng không.' },
    { key:'slide-13', url:'aviation-slide-13.html', title:'13: Diễn Biến (Sương Mù)', notes: 'Timeline 3 giai đoạn của thảm họa Tenerife: Sân bay đông đúc trong sương mù dày đặc, lỗi giao tiếp và hiểu lầm tín hiệu, dẫn đến va chạm của hai máy bay B747.' },
    { key:'slide-14', url:'aviation-slide-14.html', title:'14: Giải Pháp (Sương Mù)', notes: 'Các giải pháp được áp dụng sau thảm họa: Chuẩn hóa thuật ngữ giao tiếp hàng không toàn cầu, áp dụng bắt buộc huấn luyện Quản lý Tổ lái (CRM), và phát triển công nghệ hỗ trợ như ILS và radar mặt đất.', stepCount: 2 },
    { key:'slide-15', url:'aviation-slide-15.html', title:'15: Case Study: Băng Giá', notes: 'Case Study 4: Tuyết & Băng giá - Sự cố của chuyến bay Air Florida 90.',stepCount: 4 },
    { key:'slide-16', url:'aviation-slide-16.html', title:'16: Công Nghệ Vượt Bão', notes: 'Giới thiệu các công nghệ an toàn hàng không mới với hiệu ứng carousel.', stepCount: 4 },
    { key:'slide-17', url:'aviation-slide-17.html', title:'17: Diễn Biến (Băng Giá)', notes: 'Timeline 3 giai đoạn của sự cố Air Florida 90: Chờ đợi lâu sau khi khử băng, phi công không bật hệ thống chống băng động cơ, và cất cánh với băng trên cánh.',stepCount: 4 },
    { key:'slide-18', url:'aviation-slide-18.html', title:'18: Bảng Tổng Hợp', notes: 'Bảng tóm tắt các sự cố, hiện tượng thời tiết, thiệt hại và các biện pháp cải tiến chính đã được thảo luận.' },
    { key:'slide-19', url:'aviation-slide-19.html', title:'19: Tóm Tắt & Toàn Cảnh', notes: 'Tổng kết lại các vấn đề, tác động và giải pháp, nhấn mạnh sự kết hợp giữa Công nghệ, Quy trình và Huấn luyện.' },
    { key:'slide-20', url:'aviation-slide-20.html', title:'20: Cảm Ơn & Hỏi Đáp', notes: 'Phần kết thúc và Q&A.' }
  ];

  // DOM
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const autoplayBtn = document.getElementById('autoplayBtn');
  const statusEl = document.getElementById('status');
  const treeList = document.getElementById('treeList');
  const infoBar = document.getElementById('infoBar');
  const infoTitle = document.getElementById('infoTitle');
  const infoNotes = document.getElementById('infoNotes');
  const infoPrev = document.getElementById('infoPrev');
  const infoNext = document.getElementById('infoNext');
  const infoOpen = document.getElementById('infoOpen');
  const poolAnchor = document.getElementById('iframePoolAnchor');

  // state
  let currentIndex = 0;
  let autoplay = false;
  let autoplayTimer = null;
  let isTransitioning = false;
  let lastClickedIndex = null;
  let currentIframe = null;
  let slideSteps = {}; // stores internal step per slide index
  const iframePool = new Map();

  // tuning params (đã giảm delay, preload 4 frames, giảm step delays)
  const PRELOAD_COUNT = 4;            // preload 4 frames
  const SEND_STEP_TICK = 20;         // ms between setStep and animate-slide (was 40)
  const FRAME_FADE_TIMEOUT = 520;    // ms max wait for CSS transition end (was 900)
  const ANIMATE_OPTIONS_DEFAULT = { baseDelay: 16, per: 80, duration: 420 }; // reduced delays
  const AUTOPLAY_INTERVAL = 3000;    // ms between auto-advance (reduced for snappier flow)

  function updateStatus(){ statusEl.textContent = `Slide ${currentIndex+1} / ${slideMap.length}`; }

  function buildTree(){
    treeList.innerHTML = '';
    slideMap.forEach((s, idx) => {
      const b = document.createElement('button');
      b.className = 'tree-item';
      b.textContent = s.title || s.key;
      b.dataset.index = idx;
      b.addEventListener('click', () => {
        lastClickedIndex = idx;
        highlightTree(idx);
        showIndex(idx);
        document.getElementById('frame-wrap').focus();
      });
      treeList.appendChild(b);
    });
    highlightTree(currentIndex);
  }
  function highlightTree(idx){
    const items = treeList.querySelectorAll('.tree-item');
    items.forEach((it,i) => it.classList.toggle('active', i === idx));
  }

  // info bar show/hide
  let hoverTimer = null;
  function scheduleInfoShow(){ clearTimeout(hoverTimer); hoverTimer = setTimeout(()=> { infoBar.classList.add('visible'); infoBar.setAttribute('aria-hidden','false'); }, 600); }
  function cancelInfoShow(){ clearTimeout(hoverTimer); }
  function hideInfo(){ cancelInfoShow(); infoBar.classList.remove('visible'); infoBar.setAttribute('aria-hidden','true'); }
  const frameWrapEl = document.getElementById('frame-wrap');
  frameWrapEl.addEventListener('mouseenter', scheduleInfoShow);
  frameWrapEl.addEventListener('mouseleave', hideInfo);

  function updateInfoContent(){
    const s = slideMap[currentIndex];
    infoTitle.textContent = s.title || s.key;
    infoNotes.textContent = s.notes || '(chưa có notes)';
  }
  infoPrev.addEventListener('click', ()=> { lastClickedIndex = null; showPrev(); frameWrapEl.focus(); });
  infoNext.addEventListener('click', ()=> { lastClickedIndex = null; showNext(); frameWrapEl.focus(); });
  infoOpen.addEventListener('click', ()=> { window.open(slideMap[currentIndex].url, '_blank'); });

  // create iframe for index (lazy: will set src immediately here; we ensure parent sends 'reset' on load)
  function makeIframeFor(index, url){
    if (iframePool.has(index)) return iframePool.get(index);
    const iframe = document.createElement('iframe');
    iframe.setAttribute('data-index', index);
    iframe.dataset.index = index;
    iframe.src = url; // keep preload behavior; we will ensure reset on load
    iframe.style.position = 'absolute';
    iframe.style.inset = '0';
    iframe.style.border = '0';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.className = 'bottom';
    iframe.setAttribute('aria-hidden','true');
    iframe.setAttribute('allow','autoplay');
    iframe.title = `slide-${index+1}`;

    let resolveLoad;
    const loadingPromise = new Promise((res) => { resolveLoad = res; });

    iframe.addEventListener('load', () => {
      iframe.__loaded = true;
      try {
        // Gửi 'reset' khi preload xong để chắc trạng thái nội bộ iframe không auto-animate
        iframe.contentWindow.postMessage({ type: 'reset' }, '*');
        console.debug(`[iframe:${index}] load -> sent reset`);
      } catch (e) {
        console.debug(`[iframe:${index}] load -> postMessage reset failed`, e);
      }
      try { resolveLoad(); } catch(e){}
      // ensure internal step is reset in parent tracking
      slideSteps[index] = 0;
    });

    poolAnchor.appendChild(iframe);
    const entry = { el: iframe, loadingPromise, resolveLoad };
    iframePool.set(index, entry);
    return entry;
  }

  async function ensureIframeLoaded(index){
    if (index < 0 || index >= slideMap.length) throw new Error('index out of range');
    const s = slideMap[index];
    const existing = iframePool.get(index);
    if (existing) {
      if (existing.el.__loaded) return existing.el;
      await existing.loadingPromise;
      return existing.el;
    } else {
      const entry = makeIframeFor(index, s.url);
      await entry.loadingPromise;
      return entry.el;
    }
  }

  function computeBase(){ return (lastClickedIndex !== null) ? lastClickedIndex : currentIndex; }

  // helper: safePostMessage with simple retry and debug
  function safePostMessage(targetIframe, msg, maxRetries = 1, retryDelay = 80){
    if (!targetIframe || !targetIframe.contentWindow) {
      console.debug('safePostMessage: iframe not ready', msg);
      return Promise.reject(new Error('iframe-not-ready'));
    }
    return new Promise((resolve) => {
      let attempts = 0;
      function trySend(){
        attempts++;
        try {
          targetIframe.contentWindow.postMessage(msg, '*');
          console.debug(`[iframe:${targetIframe.dataset.index}] postMessage`, msg);
          resolve(true);
        } catch (err) {
          console.debug(`[iframe:${targetIframe.dataset.index}] postMessage failed attempt ${attempts}`, err);
          if (attempts <= maxRetries) {
            setTimeout(trySend, retryDelay);
          } else {
            resolve(false);
          }
        }
      }
      trySend();
    });
  }

  // ----------------- START: Internal-step aware navigation -----------------
  async function showIndexCached(index){
    if (index < 0 || index >= slideMap.length) return;
    // initialize stored step if needed
    slideSteps[index] = slideSteps[index] || 0;

    if (index === currentIndex) {
      // already visible — ensure it's in sync (send setStep & animate)
      try {
        const desired = slideSteps[index] || 0;
        if (currentIframe && currentIframe.contentWindow) {
          await safePostMessage(currentIframe, { type: 'setStep', step: desired, animate: false }, 1, 40);
          setTimeout(()=> {
            safePostMessage(currentIframe, { type: 'animate-slide', options: ANIMATE_OPTIONS_DEFAULT }, 1, 40).catch(()=>{});
          }, SEND_STEP_TICK);
        }
      } catch(e){ console.debug('showIndexCached(sync) error', e); }
      return;
    }

    while (isTransitioning) await new Promise(r => setTimeout(r, 16));
    isTransitioning = true;
    try {
      const targetEl = await ensureIframeLoaded(index);

      // if have current iframe, reset it and hide
      if (currentIframe && currentIframe !== targetEl){
        try {
          safePostMessage(currentIframe, { type: 'reset' }).catch(()=>{});
        } catch(e){ console.debug('reset currentIframe error', e); }
        currentIframe.classList.remove('top');
        currentIframe.classList.add('bottom');
        currentIframe.setAttribute('aria-hidden','true');
      }

      // bring target up
      targetEl.classList.add('top');
      targetEl.classList.remove('bottom');
      targetEl.setAttribute('aria-hidden','false');

      // allow frame paint (use RAF twice for safety)
      await new Promise(r => requestAnimationFrame(r));
      await new Promise(r => requestAnimationFrame(r));

      // wait transition end (or timeout)
      await new Promise(resolve => {
        let done = false;
        function onEnd(e){
          if (e.target !== targetEl || e.propertyName !== 'opacity') return;
          if (done) return; done = true;
          targetEl.removeEventListener('transitionend', onEnd);
          resolve();
        }
        targetEl.addEventListener('transitionend', onEnd);
        setTimeout(()=> { if (!done) { done=true; targetEl.removeEventListener('transitionend', onEnd); resolve(); } }, FRAME_FADE_TIMEOUT);
      });

      // update state
      currentIframe = targetEl;
      currentIndex = index;
      lastClickedIndex = null;
      highlightTree(index);
      updateStatus();
      updateInfoContent();

      // Determine desired internal step for this slide
      const entry = slideMap[index] || {};
      const desiredStep = (typeof entry.initialStep === 'number') ? entry.initialStep : (slideSteps[index] || 0);

      // send setStep (do not animate yet), then animate-slide (reduced tick)
      await safePostMessage(currentIframe, { type: 'setStep', step: desiredStep, animate: false }, 2, 50);
      setTimeout(()=> {
        safePostMessage(currentIframe, { type: 'animate-slide', options: ANIMATE_OPTIONS_DEFAULT }, 2, 50).catch(()=>{});
      }, SEND_STEP_TICK);

      // ask for notes if supported
      safePostMessage(currentIframe, {type:'getNotes'}).catch(()=>{});
    } finally {
      isTransitioning = false;
      // ensure we keep a small pool preloaded around current index
      preloadAround(currentIndex);
    }
  }

  // wrapper (keeps API)
  async function showIndex(index){ return showIndexCached(index); }

  // Next/Prev: if current slide has internal steps (stepCount > 1) then
  // toggle internal step inside the same iframe; otherwise move to next/prev iframe.
  function showNext(){
    const s = slideMap[currentIndex] || {};
    const stepCount = (typeof s.stepCount === 'number') ? s.stepCount : 1;
    // if slide supports internal steps and not on last step, increment internal step
    if (stepCount > 1) {
      slideSteps[currentIndex] = slideSteps[currentIndex] || 0;
      if (slideSteps[currentIndex] < stepCount - 1) {
        slideSteps[currentIndex] += 1;
        // instruct iframe to change step and animate (reduced tick)
        safePostMessage(currentIframe, { type: 'setStep', step: slideSteps[currentIndex], animate: false }, 2, 60).then(()=> {
          setTimeout(()=> {
            safePostMessage(currentIframe, { type: 'animate-slide', options: ANIMATE_OPTIONS_DEFAULT }, 2, 60).catch(()=>{});
          }, SEND_STEP_TICK);
        }).catch(()=>{ console.debug('showNext: setStep failed'); });
        return;
      }
    }
    // otherwise go to next iframe entry
    const base = computeBase();
    const next = Math.min(slideMap.length-1, base+1);
    lastClickedIndex = null;
    showIndex(next);
  }

  function showPrev(){
    const s = slideMap[currentIndex] || {};
    const stepCount = (typeof s.stepCount === 'number') ? s.stepCount : 1;
    // if slide supports internal steps and not on first step, decrement internal step
    if (stepCount > 1) {
      slideSteps[currentIndex] = slideSteps[currentIndex] || 0;
      if (slideSteps[currentIndex] > 0) {
        slideSteps[currentIndex] -= 1;
        safePostMessage(currentIframe, { type: 'setStep', step: slideSteps[currentIndex], animate: false }, 2, 60).then(()=> {
          setTimeout(()=> {
            safePostMessage(currentIframe, { type: 'animate-slide', options: ANIMATE_OPTIONS_DEFAULT }, 2, 60).catch(()=>{});
          }, SEND_STEP_TICK);
        }).catch(()=>{ console.debug('showPrev: setStep failed'); });
        return;
      }
    }
    // otherwise navigate to previous iframe
    const base = computeBase();
    const prev = Math.max(0, base-1);
    lastClickedIndex = null;
    showIndex(prev);
  }
  // ----------------- END: Internal-step aware navigation -----------------

  prevBtn.addEventListener('click', ()=> { lastClickedIndex = null; showPrev(); frameWrapEl.focus(); });
  nextBtn.addEventListener('click', ()=> { lastClickedIndex = null; showNext(); frameWrapEl.focus(); });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { e.preventDefault(); lastClickedIndex = null; showNext(); }
    if (e.key === 'ArrowLeft' || e.key === 'PageUp') { e.preventDefault(); lastClickedIndex = null; showPrev(); }
    if (e.key === ' '){ e.preventDefault(); toggleAutoplay(); }
    if (e.key.toLowerCase() === 'n') {
      const left = document.getElementById('leftPanel');
      left.classList.toggle('expanded');
    }
  });
  document.addEventListener("mousedown", function(e){
  if (!bodyEl.classList.contains("immersive")) return;

  e.stopPropagation();

  if (e.button === 0){        // left click = NEXT
    e.preventDefault();
    lastClickedIndex = null;
    showNext();
    frameWrapEl.focus();
  }

  if (e.button === 2){        // right click = PREVIOUS
    e.preventDefault();
    lastClickedIndex = null;
    showPrev();
    frameWrapEl.focus();
  }
});

// Chặn menu chuột phải
document.addEventListener("contextmenu", function(e){
  if (bodyEl.classList.contains("immersive")) {
    e.preventDefault();
  }
});


  function startAutoplay(){
    stopAutoplay();
    autoplay = true; autoplayBtn.textContent = 'Autoplay ◼';
    autoplayTimer = setInterval(()=> {
      if (currentIndex < slideMap.length - 1) showNext();
      else { stopAutoplay(); }
    }, AUTOPLAY_INTERVAL);
  }
  function stopAutoplay(){ autoplay = false; autoplayBtn.textContent = 'Autoplay ▶'; if (autoplayTimer){ clearInterval(autoplayTimer); autoplayTimer = null; } }
  function toggleAutoplay(){ if (autoplay) stopAutoplay(); else startAutoplay(); }
  autoplayBtn.addEventListener('click', toggleAutoplay);

  // preload helper: keep PRELOAD_COUNT frames around current index prepared
  function preloadAround(index){
    const start = Math.max(0, index - 0);
    const end = Math.min(slideMap.length - 1, index + (PRELOAD_COUNT - 1));
    for (let i = start; i <= end; i++){
      if (!iframePool.has(i)) {
        makeIframeFor(i, slideMap[i].url);
      }
    }
  }

  // build and initial show
  function initialSetup(){
    buildTree();
    updateStatus();
    updateInfoContent();

    // create iframe 0 immediately
    const e0 = makeIframeFor(0, slideMap[0].url);
    e0.loadingPromise.then(() => {
      currentIframe = e0.el;
      e0.el.classList.add('top');
      e0.el.classList.remove('bottom');
      e0.el.setAttribute('aria-hidden','false');

      // GỌI: khi slide 0 hiển thị lần đầu, gửi animate-slide thay vì 'show' (sử dụng reduced options)
      safePostMessage(e0.el, {type:'animate-slide', options:ANIMATE_OPTIONS_DEFAULT}).catch(()=>{});
      safePostMessage(e0.el, {type:'getNotes'}).catch(()=>{});
    });

    // preload next PRELOAD_COUNT-1 to reduce latency (optional)
    for (let i = 1; i < PRELOAD_COUNT && i < slideMap.length; i++){
      makeIframeFor(i, slideMap[i].url);
    }
  }

  window._iframePoolAPI = { makeIframeFor, ensureIframeLoaded, showIndex, showNext, showPrev, iframePool, slideMap };

  initialSetup();

  window.addEventListener('beforeunload', ()=> {
    try { if (currentIframe) currentIframe.contentWindow.postMessage({type:'hide'}, '*'); } catch(e){ console.debug('beforeunload post hide failed', e); }
  });

  // optional: listener for debug messages back from iframe
  window.addEventListener('message', (ev) => {
    if (!ev.data) return;
    if (ev.data && ev.data.type === 'debug') {
      console.debug('iframe-debug:', ev.data);
    }
    if (ev.data && ev.data.type === 'notes') {
      // iframe can respond with notes: update UI
      try {
        const notes = ev.data.notes || '';
        document.getElementById('infoNotes').textContent = notes || '(chưa có notes)';
      } catch(e){}
    }
  });

})();
</script>
</body>
</html>
